TabWidget

Next:
	- When moving widgets around, splitter sizes should be remembered.
	- Ability to drop to edges of the screen.
	
Low Priority:
	- Floating window.
	- Save layout.
	- Improve visualisation. Make it even more clear where the dragged widget will end up.






//source
	dragging Last Tab
		-remove index
	source Tabs Remain
//target
	drop To Tabbar
	drop on Index
		-insert to existing splitter
		-split index to two pieces



bool createNewSplitter

//case of source splitter
//NOTE!!!!! You also need to do this when dropping on tabbar.
if (!droppedOnSelf) {
	if (sourceWidgetIndex != -1) {
		//dragging last tab
		int removedSize = sourceSplitter.sizes().at(sourceWidgetIndex);
		sourceSplitter.sizes.remove(sourceWidgetIndex);
	} else {
		//tabs still remain in the sourceSplitter, so nothing was removed.
	}
}



//case of target splitter
if (droppedOnSelf) {
	if (sourceWidgetIndex != -1) {
		if (!createNewSplitter) {
			targetSplitter.sizes().remove(sourceWidgetIndex);
		} else {
			//widget only moved internally
			targetSplitter.sizes().move(sourceWidgetIndex, targetIndex);
		}
	} else {
		//tabs still remain in the sourceSplitter

		if (createNewSplitter) {
			//no need for size changes
		} else {
			//insert to target splitter, with min size.
			targetSplitter.sizes().insert(targetIndex, minimumSizeHint.size().height());
		}
	}
}
if (!droppedOnSelf) {
	if (createNewSplitter) {
		//no need for size change for targetSplitter
	} else {
		//inserting to targetSplitter
		//NOTE!!!! removedSize might not be correct if it's in the wrong orientation.
		targetSplitter.sizes().insert(targetIndex, removedSize);
	}
} 


if (createNewSplitter) {
	//case of new splitter
	newSplitter.sizes = { halfSize, halfSize };
}
